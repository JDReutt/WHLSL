Notes on converting WHLSL to SPIR-V (for Vulkan)
------------------------------------------------

The SPIR-V code generator lives in [Source/spirv](Source/spirv). It's
nowhere near complete at the moment. The goal is for it to be able
to translate a WHLSL program into binary SPIR-V or the textual
assembly format.

This document contains the information on how the SPIR-V is generated.

## Notes

- In WHLSL, entry points can have return values and parameters. The
  SPIR-V accepted by Vulkan requires entry points to have no return
  values and no parameters. Instead, everything is passed in or out
  via global variables. So WHLSL values/params will be flattened
  into the global variables.

- For now, the WHLSL semantics for attribute(N) maps to GLSL location=N.
  The WHLSL semantic SV_Position maps to SPIR-V Output Location.

- There has been no effort at optimising the SPIR-V e.g. for built-in
  types. A WHLSL cast to float4 uses a standard library function that
  is copied into the output SPIR-V.

## Sample Files

In [Misc](Misc) there is a _simple_ vertex and fragment shader in WHLSL,
along with the SPIR-V form generated by the official tools.

```
struct VertexInput {
    float4 position : attribute(0);
}

vertex float4 vertexShader(VertexInput vertexInput) : SV_Position
{
    return vertexInput.position;
}

struct FragmentOutput {
    float4 color : SV_Target0;
}

fragment FragmentOutput fragmentShader(float4 position : SV_Position) {
    FragmentOutput result;
    result.color = float4(1, 0, 0, 1);
    return result;
}
```

In order to produce some reference SPIR-V, these shaders were translated
into GLSL Version 4.5.

```
# VERTEX
#version 450

// Input structures are flattened into structName_attributeName.

layout(location=0) in vec4 VertexInput_position;

// The position output of the vertex shader is the
// value of gl_PerVertex.gl_Position.

void main() {
    gl_Position = VertexInput_position;
}

# FRAGMENT
#version 450

layout(location=0) out vec4 FragmentOutput_color;

struct Global {
    float float4_param1;
    float float4_param2;
    float float4_param3;
    float float4_param4;
    vec4 float4_result;
};

void float4(inout Global g) {
    g.float4_result.x = g.float4_param1;
    g.float4_result.y = g.float4_param2;
    g.float4_result.z = g.float4_param3;
    g.float4_result.w = g.float4_param4;
}

void main() {
    Global g;
    g.float4_param1 = 1;
    g.float4_param2 = 0;
    g.float4_param3 = 0;
    g.float4_param4 = 1;
    float4(g);

    FragmentOutput_color = g.float4_result;
}
```

Note that the `float4()` cast is translated into a function that takes a single
parameter with fields for the parameters and return values. That's what the WHLSL
compiler produces, but obviously the code generator could optimize that away.

The GLSL is then compiled into SPIR-V.

```bash
prompt> glslangValidator -H -V -o simple-vert.spv simple.vert
prompt> glslangValidator -H -V -o simple-frag.spv simple.frag
```

And since binary SPIR-V is hard to read, it's then disassembled
back into text.

```bash
prompt> spirv-dis -o simple-vert.txt simple-vert.spv
prompt> spirv-dis -o simple-frag.txt simple-frag.spv
```

Producing the following, hopefully correct, SPIR-V translation:

```
; SPIR-V
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 7
; Bound: 21
; Schema: 0
               OpCapability Shader
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Vertex %main "main" %_ %VertexInput_position
               OpSource GLSL 450
               OpName %main "main"
               OpName %gl_PerVertex "gl_PerVertex"
               OpMemberName %gl_PerVertex 0 "gl_Position"
               OpMemberName %gl_PerVertex 1 "gl_PointSize"
               OpMemberName %gl_PerVertex 2 "gl_ClipDistance"
               OpMemberName %gl_PerVertex 3 "gl_CullDistance"
               OpName %_ ""
               OpName %VertexInput_position "VertexInput_position"
               OpMemberDecorate %gl_PerVertex 0 BuiltIn Position
               OpMemberDecorate %gl_PerVertex 1 BuiltIn PointSize
               OpMemberDecorate %gl_PerVertex 2 BuiltIn ClipDistance
               OpMemberDecorate %gl_PerVertex 3 BuiltIn CullDistance
               OpDecorate %gl_PerVertex Block
               OpDecorate %VertexInput_position Location 0
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
       %uint = OpTypeInt 32 0
     %uint_1 = OpConstant %uint 1
%_arr_float_uint_1 = OpTypeArray %float %uint_1
%gl_PerVertex = OpTypeStruct %v4float %float %_arr_float_uint_1 %_arr_float_uint_1
%_ptr_Output_gl_PerVertex = OpTypePointer Output %gl_PerVertex
          %_ = OpVariable %_ptr_Output_gl_PerVertex Output
        %int = OpTypeInt 32 1
      %int_0 = OpConstant %int 0
%_ptr_Input_v4float = OpTypePointer Input %v4float
%VertexInput_position = OpVariable %_ptr_Input_v4float Input
%_ptr_Output_v4float = OpTypePointer Output %v4float
       %main = OpFunction %void None %3
          %5 = OpLabel
         %18 = OpLoad %v4float %VertexInput_position
         %20 = OpAccessChain %_ptr_Output_v4float %_ %int_0
               OpStore %20 %18
               OpReturn
               OpFunctionEnd


; SPIR-V
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 7
; Bound: 54
; Schema: 0
               OpCapability Shader
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %FragmentOutput_color
               OpExecutionMode %main OriginUpperLeft
               OpSource GLSL 450
               OpName %main "main"
               OpName %Global "Global"
               OpMemberName %Global 0 "float4_param1"
               OpMemberName %Global 1 "float4_param2"
               OpMemberName %Global 2 "float4_param3"
               OpMemberName %Global 3 "float4_param4"
               OpMemberName %Global 4 "float4_result"
               OpName %float4_struct_Global_f1_f1_f1_f1_vf41_ "float4(struct-Global-f1-f1-f1-f1-vf41;"
               OpName %g "g"
               OpName %g_0 "g"
               OpName %param "param"
               OpName %FragmentOutput_color "FragmentOutput_color"
               OpDecorate %FragmentOutput_color Location 0
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
     %Global = OpTypeStruct %float %float %float %float %v4float
%_ptr_Function_Global = OpTypePointer Function %Global
         %10 = OpTypeFunction %void %_ptr_Function_Global
        %int = OpTypeInt 32 1
      %int_4 = OpConstant %int 4
      %int_0 = OpConstant %int 0
%_ptr_Function_float = OpTypePointer Function %float
       %uint = OpTypeInt 32 0
     %uint_0 = OpConstant %uint 0
      %int_1 = OpConstant %int 1
     %uint_1 = OpConstant %uint 1
      %int_2 = OpConstant %int 2
     %uint_2 = OpConstant %uint 2
      %int_3 = OpConstant %int 3
     %uint_3 = OpConstant %uint 3
    %float_1 = OpConstant %float 1
    %float_0 = OpConstant %float 0
%_ptr_Output_v4float = OpTypePointer Output %v4float
%FragmentOutput_color = OpVariable %_ptr_Output_v4float Output
%_ptr_Function_v4float = OpTypePointer Function %v4float
       %main = OpFunction %void None %3
          %5 = OpLabel
        %g_0 = OpVariable %_ptr_Function_Global Function
      %param = OpVariable %_ptr_Function_Global Function
         %40 = OpAccessChain %_ptr_Function_float %g_0 %int_0
               OpStore %40 %float_1
         %42 = OpAccessChain %_ptr_Function_float %g_0 %int_1
               OpStore %42 %float_0
         %43 = OpAccessChain %_ptr_Function_float %g_0 %int_2
               OpStore %43 %float_0
         %44 = OpAccessChain %_ptr_Function_float %g_0 %int_3
               OpStore %44 %float_1
         %46 = OpLoad %Global %g_0
               OpStore %param %46
         %47 = OpFunctionCall %void %float4_struct_Global_f1_f1_f1_f1_vf41_ %param
         %48 = OpLoad %Global %param
               OpStore %g_0 %48
         %52 = OpAccessChain %_ptr_Function_v4float %g_0 %int_4
         %53 = OpLoad %v4float %52
               OpStore %FragmentOutput_color %53
               OpReturn
               OpFunctionEnd
%float4_struct_Global_f1_f1_f1_f1_vf41_ = OpFunction %void None %10
          %g = OpFunctionParameter %_ptr_Function_Global
         %13 = OpLabel
         %18 = OpAccessChain %_ptr_Function_float %g %int_0
         %19 = OpLoad %float %18
         %22 = OpAccessChain %_ptr_Function_float %g %int_4 %uint_0
               OpStore %22 %19
         %24 = OpAccessChain %_ptr_Function_float %g %int_1
         %25 = OpLoad %float %24
         %27 = OpAccessChain %_ptr_Function_float %g %int_4 %uint_1
               OpStore %27 %25
         %29 = OpAccessChain %_ptr_Function_float %g %int_2
         %30 = OpLoad %float %29
         %32 = OpAccessChain %_ptr_Function_float %g %int_4 %uint_2
               OpStore %32 %30
         %34 = OpAccessChain %_ptr_Function_float %g %int_3
         %35 = OpLoad %float %34
         %37 = OpAccessChain %_ptr_Function_float %g %int_4 %uint_3
               OpStore %37 %35
               OpReturn
               OpFunctionEnd
```

## Tools

- [glslang](https://github.com/KhronosGroup/glslang) - for compiling a GLSL file into SPIR-V (useful to see what SPIR-V should look like)
- [SPIRV-Tools](https://github.com/KhronosGroup/SPIRV-Tools) - for validating and disassembling a SPIR-V file
- [SPIRV-Headers](https://github.com/KhronosGroup/SPIRV-Headers) - needed for the other tools
- [SPIRV-Cross](https://github.com/KhronosGroup/SPIRV-Cross) - if you want to translate the SPIR-V back into a human-readable format


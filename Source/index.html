<!DOCTYPE html>
<!--
Copyright 2018 Apple Inc.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

   3. Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from this
      software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html>
<head>
<script src="Node.mjs"></script>
<script src="Type.mjs"></script>
<script src="ReferenceType.mjs"></script>
<script src="Value.mjs"></script>
<script src="Expression.mjs"></script>
<script src="Rewriter.mjs"></script>
<script src="Visitor.mjs"></script>
<script src="CreateLiteral.mjs"></script>
<script src="CreateLiteralType.mjs"></script>
<script src="PropertyAccessExpression.mjs"></script>
<script src="NativeType.mjs"></script>
<script src="Semantic.mjs"></script>

<script src="AddressSpace.mjs"></script>
<script src="AllocateAtEntryPoints.mjs"></script>
<script src="AnonymousVariable.mjs"></script>
<script src="ArrayRefType.mjs"></script>
<script src="ArrayType.mjs"></script>
<script src="Assignment.mjs"></script>
<script src="AutoWrapper.mjs"></script>
<script src="Block.mjs"></script>
<script src="BoolLiteral.mjs"></script>
<script src="Break.mjs"></script>
<script src="BuiltInSemantic.mjs"></script>
<script src="BuiltinMatrixGetter.mjs"></script>
<script src="BuiltinMatrixSetter.mjs"></script>
<script src="BuiltinVectorGetter.mjs"></script>
<script src="BuiltinVectorSetter.mjs"></script>
<script src="CallExpression.mjs"></script>
<script src="CallFunction.mjs"></script>
<script src="Casts.mjs"></script>
<script src="Check.mjs"></script>
<script src="CheckLiteralTypes.mjs"></script>
<script src="CheckLoops.mjs"></script>
<script src="CheckNativeFuncStages.mjs"></script>
<script src="CheckRecursion.mjs"></script>
<script src="CheckRecursiveTypes.mjs"></script>
<script src="CheckReturns.mjs"></script>
<script src="CheckUnreachableCode.mjs"></script>
<script src="CheckTypesWithArguments.mjs"></script>
<script src="CheckWrapped.mjs"></script>
<script src="Checker.mjs"></script>
<script src="CloneProgram.mjs"></script>
<script src="CommaExpression.mjs"></script>
<script src="ConstexprFolder.mjs"></script>
<script src="Continue.mjs"></script>
<script src="ConvertPtrToArrayRefExpression.mjs"></script>
<script src="DoWhileLoop.mjs"></script>
<script src="DotExpression.mjs"></script>
<script src="DereferenceExpression.mjs"></script>
<script src="EArrayRef.mjs"></script>
<script src="EBuffer.mjs"></script>
<script src="EBufferBuilder.mjs"></script>
<script src="EPtr.mjs"></script>
<script src="EnumLiteral.mjs"></script>
<script src="EnumMember.mjs"></script>
<script src="EnumType.mjs"></script>
<script src="EvaluationCommon.mjs"></script>
<script src="Evaluator.mjs"></script>
<script src="ExpressionFinder.mjs"></script>
<script src="ExternalOrigin.mjs"></script>
<script src="Field.mjs"></script>
<script src="FindHighZombies.mjs"></script>
<script src="FlattenedStructOffsetGatherer.mjs"></script>
<script src="FloatLiteral.mjs"></script>
<script src="FloatLiteralType.mjs"></script>
<script src="FoldConstexprs.mjs"></script>
<script src="ForLoop.mjs"></script>
<script src="Func.mjs"></script>
<script src="FuncAttribute.mjs"></script>
<script src="FuncDef.mjs"></script>
<script src="FuncNumThreadsAttribute.mjs"></script>
<script src="FuncParameter.mjs"></script>
<script src="FunctionLikeBlock.mjs"></script>
<script src="HighZombieFinder.mjs"></script>
<script src="IdentityExpression.mjs"></script>
<script src="IfStatement.mjs"></script>
<script src="IndexExpression.mjs"></script>
<script src="InferTypesForCall.mjs"></script>
<script src="Inline.mjs"></script>
<script src="Inliner.mjs"></script>
<script src="IntLiteral.mjs"></script>
<script src="IntLiteralType.mjs"></script>
<script src="Intrinsics.mjs"></script>
<script src="LayoutBuffers.mjs"></script>
<script src="Lexer.mjs"></script>
<script src="LexerToken.mjs"></script>
<script src="LiteralTypeChecker.mjs"></script>
<script src="LogicalExpression.mjs"></script>
<script src="LogicalNot.mjs"></script>
<script src="LoopChecker.mjs"></script>
<script src="MakeArrayRefExpression.mjs"></script>
<script src="MakePtrExpression.mjs"></script>
<script src="MatrixType.mjs"></script>
<script src="NameContext.mjs"></script>
<script src="NameFinder.mjs"></script>
<script src="NameResolver.mjs"></script>
<script src="NativeFunc.mjs"></script>
<script src="NormalUsePropertyResolver.mjs"></script>
<script src="NullLiteral.mjs"></script>
<script src="NullType.mjs"></script>
<script src="OperatorAnderIndexer.mjs"></script>
<script src="OperatorArrayRefLength.mjs"></script>
<script src="OriginKind.mjs"></script>
<script src="OverloadResolutionFailure.mjs"></script>
<script src="Parse.mjs"></script>
<script src="Prepare.mjs"></script>
<script src="PropertyResolver.mjs"></script>
<script src="Program.mjs"></script>
<script src="ProgramWithUnnecessaryThingsRemoved.mjs"></script>
<script src="PtrType.mjs"></script>
<script src="ReadModifyWriteExpression.mjs"></script>
<script src="RecursionChecker.mjs"></script>
<script src="RecursiveTypeChecker.mjs"></script>
<script src="ResolveNames.mjs"></script>
<script src="ResolveOverloadImpl.mjs"></script>
<script src="ResolveProperties.mjs"></script>
<script src="ResolveTypeDefs.mjs"></script>
<script src="ResourceSemantic.mjs"></script>
<script src="Return.mjs"></script>
<script src="ReturnChecker.mjs"></script>
<script src="ReturnException.mjs"></script>
<script src="Sampler.mjs"></script>
<script src="SpecializationConstantSemantic.mjs"></script>
<script src="StageInOutSemantic.mjs"></script>
<script src="StandardLibrary.mjs"></script>
<script src="StatementCloner.mjs"></script>
<script src="StructLayoutBuilder.mjs"></script>
<script src="StructType.mjs"></script>
<script src="SwitchCase.mjs"></script>
<script src="SwitchStatement.mjs"></script>
<script src="SynthesizeArrayOperatorLength.mjs"></script>
<script src="SynthesizeEnumFunctions.mjs"></script>
<script src="SynthesizeStructAccessors.mjs"></script>
<script src="SynthesizeCopyConstructorOperator.mjs"></script>
<script src="SynthesizeDefaultConstructorOperator.mjs"></script>
<script src="TernaryExpression.mjs"></script>
<script src="Texture.mjs"></script>
<script src="TextureOperations.mjs"></script>
<script src="TrapStatement.mjs"></script>
<script src="TypeDef.mjs"></script>
<script src="TypeDefResolver.mjs"></script>
<script src="TypeRef.mjs"></script>
<script src="TypeOverloadResolutionFailure.mjs"></script>
<script src="TypedValue.mjs"></script>
<script src="UintLiteral.mjs"></script>
<script src="UintLiteralType.mjs"></script>
<script src="UnificationContext.mjs"></script>
<script src="UnreachableCodeChecker.mjs"></script>
<script src="VariableDecl.mjs"></script>
<script src="VariableRef.mjs"></script>
<script src="VectorType.mjs"></script>
<script src="VisitingSet.mjs"></script>
<script src="WLexicalError.mjs"></script>
<script src="WSyntaxError.mjs"></script>
<script src="WTrapError.mjs"></script>
<script src="WTypeError.mjs"></script>
<script src="WhileLoop.mjs"></script>
<script src="WrapChecker.mjs"></script>
<style>
#ShaderSource {
    font-family: monospace;
    width: 700px;
    height: 400px;
}

td {
    border: 1px solid black;
}
</style>
<script>
let defaultShaderSource = `struct VertexInput {
    float2 position;
    float3 color;
}

struct VertexOutput {
    float4 wsl_Position;
    float3 color;
}

struct FragmentOutput {
    float4 wsl_Color;
}

vertex VertexOutput vertexShader(VertexInput vertexInput) {
    VertexOutput result;
    result.wsl_Position = float4(vertexInput.position, 0., 1.);
    result.color = vertexInput.color;
    return result;
}

fragment FragmentOutput fragmentShader(VertexOutput stageIn) {
    FragmentOutput result;
    result.wsl_Color = float4(stageIn.color, 1.);
    return result;
}`;

let shaderSourceTextarea;
let compileButton;
let localStorage;
let compileLogElement;
let vertexShaderSelect;
let fragmentShaderSelect;
let dataTable;
let resultTable;

let program;
let availableVertexShaders;
let availableFragmentShaders;
let currentVertexShader;
let currentFragmentShader;
let allArgumentInfos;
let argumentEPtrs;
let stageInArgumentIndex;

window.addEventListener("load", function() {
    shaderSourceTextarea = document.getElementById("ShaderSource");
    compileButton = document.getElementById("CompileButton");
    compileButton.addEventListener("click", compilePresentShaderSource);
    compileLogElement = document.getElementById("CompileLog");
    vertexShaderSelect = document.getElementById("VertexShaderSelect");
    fragmentShaderSelect = document.getElementById("FragmentShaderSelect");
    vertexShaderSelect.addEventListener("change", selectedShadersChanged);
    fragmentShaderSelect.addEventListener("change", selectedShadersChanged);
    dataTable = document.getElementById("DataTable");
    document.getElementById("RunButton").addEventListener("click", runShaders);
    resultTable = document.getElementById("ResultTable");
    shaderSourceTextarea.addEventListener("input", sourceCodeChanged);

    let shaderSource;
    try {
        localStorage = window.localStorage;
        shaderSource = localStorage.getItem("ShaderSource");
    } catch (e) {
    }

    if (!shaderSource)
        shaderSource = defaultShaderSource;
    shaderSourceTextarea.value = shaderSource;
    window.setTimeout(compilePresentShaderSource, 0);
});

function clearDataTable()
{
    while (dataTable.lastChild instanceof HTMLTableRowElement)
        dataTable.removeChild(dataTable.lastChild);
}

function clearResultTable()
{
    while (resultTable.lastChild instanceof HTMLTableRowElement)
        resultTable.removeChild(resultTable.lastChild);
}

function clearShaderSelect()
{
    while (vertexShaderSelect.firstChild)
        vertexShaderSelect.removeChild(vertexShaderSelect.firstChild);
    while (fragmentShaderSelect.firstChild)
        fragmentShaderSelect.removeChild(fragmentShaderSelect.firstChild);
}

function sourceCodeChanged() {
    compileLogElement.textContent = "";
    clearShaderSelect();
    clearDataTable();
    clearResultTable();
}

function presentError(message) {
    compileLogElement.textContent = message;
    clearShaderSelect();
    clearDataTable();
    clearResultTable();
    throw new Error(message);
}

function compilePresentShaderSource() {
    compileLogElement.textContent = "Compiling...";
    compileButton.disabled = true;
    window.setTimeout(doCompilePresentShaderSource, 0);
}

function doCompilePresentShaderSource() {
    compileButton.disabled = false;
    let start = new Date().getTime();
    let result;
    try {
        result = prepare("/internal/test", 0, shaderSourceTextarea.value);
    } catch (e) {
        result = e;
    }
    let end = new Date().getTime();
    if (!(result instanceof Program)) {
        compileLogElement.textContent = result.toString();
        return;
    } else
        compileLogElement.textContent = "Compile successful!";

    try {
        shaderSource = localStorage.setItem("ShaderSource", shaderSourceTextarea.value);
    } catch (e) {
    }

    program = result;
    availableVertexShaders = [];
    availableFragmentShaders = [];
    for (let functionNames of program.functions.values()) {
        for (let func of functionNames) {
            if (func.shaderType == "vertex")
                availableVertexShaders.push(func);
            if (func.shaderType == "fragment")
                availableFragmentShaders.push(func);
        }
    }
    clearShaderSelect();
    function createOption(textContent) {
        let option = document.createElement("option");
        option.textContent = textContent;
        return option;
    }
    for (let i = 0; i < availableVertexShaders.length; ++i)
        vertexShaderSelect.appendChild(createOption(availableVertexShaders[i].name));
    for (let i = 0; i < availableFragmentShaders.length; ++i)
        fragmentShaderSelect.appendChild(createOption(availableFragmentShaders[i].name));
    selectedShadersChanged(true);
}

function createTableRow(name, elementCallback) {
    let row = document.createElement("tr");
    let variableCell = document.createElement("td");
    let valueCell = document.createElement("td");
    variableCell.textContent = name;
    valueCell.appendChild(elementCallback());
    row.appendChild(variableCell);
    row.appendChild(valueCell);
    return row;
    dataTable.appendChild(row);
}

function linkError(message) {
    compileLogElement.textContent = message + " Fix this by selecting a different pair of shaders below.";
    clearDataTable();
    clearResultTable();
}

function selectedShadersChanged(fromCompilation = false) {
    if (!fromCompilation)
        compileLogElement.textContent = "";
    currentVertexShader = availableVertexShaders[vertexShaderSelect.selectedIndex];
    currentFragmentShader = availableFragmentShaders[fragmentShaderSelect.selectedIndex];

    _inlineFunction(program, currentVertexShader, new VisitingSet(currentVertexShader));

    allArgumentInfos = [];
    argumentEPtrs = [];
    for (let parameter of currentVertexShader.parameters) {
        let ePtr = new EPtr(new EBuffer(parameter.type.size), 0);
        argumentEPtrs.push({ePtr: ePtr, size: parameter.type.size});
        let gatherer = new FlattenedStructOffsetGatherer(parameter.name);
        parameter.visit(gatherer);
        for (let argumentInfo of gatherer.result) {
            argumentInfo.ePtr = ePtr;
            allArgumentInfos.push(argumentInfo);
        }
    }
    clearDataTable();
    clearResultTable();
    for (let info of allArgumentInfos) {
        dataTable.appendChild(createTableRow(info.name, function() {
             let input = document.createElement("input");
             input.addEventListener("input", clearResultTable);
             input.type = "text";
             return input;
        }));
    }

    let found = false;
    let index = 0;
    for (let parameter of currentFragmentShader.parameters) {
        if (parameter.name == "stageIn") {
            found = true;
            if (!parameter.type.equals(currentVertexShader.returnType))
                linkError("Vertex shader's return type needs to match the stageIn parameter of the fragment shader!");
            stageInArgumentIndex = index;
            break;
        }
        ++index;
    }
    if (!found)
        linkError("Could not find the stageIn argument in the fragment shader!");
    if (currentFragmentShader.parameters.length > 1)
        linkError("Fragment shaders currently don't know how to have any other arguments other than stageIn.");
}

function runShaders() {
    let func = currentVertexShader;

    let index = 0;
    for (let i = 0; i < dataTable.children.length; ++i) {
        let childElement = dataTable.children[i];
        if (!(childElement instanceof HTMLTableRowElement))
            continue;
        let value = childElement.children[1].firstChild.value;
        let argumentInfo = allArgumentInfos[index];
        let type = argumentInfo.type;
        // FIXME: Add support for all the other scalar types
        switch (type) {
        case "float":
            value = Math.fround(parseFloat(value));
            argumentInfo.ePtr.set(argumentInfo.offset, value);
            break;
        case "int":
            value = parseInt(value) | 0;
            break;
        case "uint":
            value = parseInt(value) >>> 0;
            break;
        default:
            presentError("I don't know how to parse values of type " + type);
        }
        if (isNaN(value))
            presentError("Could not parse input data " + index);
        argumentInfo.ePtr.set(argumentInfo.offset, value);
        ++index;
    }

    for (let i = 0; i < func.parameters.length; ++i)
        func.parameters[i].ePtr.copyFrom(argumentEPtrs[i].ePtr, argumentEPtrs[i].size);
    let result = new Evaluator(program).runFunc(func);

    _inlineFunction(program, currentFragmentShader, new VisitingSet(currentFragmentShader));
    func = currentFragmentShader;

    func.parameters[stageInArgumentIndex].ePtr.copyFrom(result, func.parameters[stageInArgumentIndex].type.size);

    result = new Evaluator(program).runFunc(func);

    clearResultTable();
    let gatherer = new FlattenedStructOffsetGatherer(func.returnType.type.name);
    func.returnType.type.visit(gatherer);
    for (let info of gatherer.result) {
        resultTable.appendChild(createTableRow(info.name, function() {
            return document.createTextNode(result.get(info.offset));
        }));
    }
}
</script>
</head>
<body>
<h1>WebGPU Shading Language</h1>
<ol>
<li>
    Write a shader!
    <div><textarea id="ShaderSource"></textarea></div>
    <div id="CompileLog"></div>
    <div><input type="button" value="Compile" id="CompileButton"></div>
</li>
<li>
    Select your shaders
    <div><label>Vertex Shader <select id="VertexShaderSelect"></select></label></div>
    <div><label>Fragment Shader <select id="FragmentShaderSelect"></select></label></div>
</li>
<li>
    Specify input data
    <table id="DataTable">
        <thead>
            <tr>
                <td>Variable</td>
                <td>Value</td>
            </tr>
        </thead>
    </table>
</li>
<li>
    <div><input type="button" value="Run" id="RunButton"></div>
    <table id="ResultTable">
        <thead>
            <tr>
                <td>Variable</td>
                <td>Value</td>
            </tr>
        </thead>
    </table>
</li>
</ol>
</body>
</html>
